{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"container mx-auto\",\n  id: \"id_container\",\n  style: {\n    \"text-align\": \"center\",\n    \"width\": \"95%\",\n    \"height\": \"70%\",\n    \"margin\": \"0 auto\"\n  }\n};\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode(\"canvas\", {\n  width: \"\",\n  height: \"\",\n  id: \"MyCanvas\"\n}, null, -1 /* HOISTED */);\nconst _hoisted_3 = [_hoisted_2];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [..._hoisted_3]);\n}","map":{"version":3,"names":["class","id","style","_createElementVNode","width","height","_hoisted_2","_createElementBlock","_hoisted_1","_hoisted_3"],"sources":["/app/vue-sample/src/components/MazeGenerator.vue"],"sourcesContent":["<template>\n  <div\n    class=\"container mx-auto\"\n    id=\"id_container\"\n    style=\"text-align: center; width: 95%; height: 70%; margin: 0 auto\"\n  >\n    <canvas width=\"\" height=\"\" id=\"MyCanvas\"></canvas>\n  </div>\n</template>\n<script lang=\"js\">\n   var wrapper = null; // キャンバスの親要素\n   var canvas = null; // キャンバス\n   var g = null; // コンテキスト\n   var $id = function (id) {\n     return document.getElementById(id);\n   }; // DOM取得用\n   // キャンバスの親要素情報取得（親要素が無いとキャンバスのサイズが画面いっぱいに表示できないため）\n   wrapper = $id(\"id_container\");\n   // キャンバス情報取得\n   canvas = $id(\"MyCanvas\");\n   g = canvas.getContext(\"2d\");\n   const margin = 10;\n   let optMarginX, optMarginY;\n   let aside;\n   let xCount, yCount;\n   let cells = [];\n   let checkedCells = [];\n   let cellX, cellY, tmpX, tmpY;\n   let dirs = [];\n   let nextDir;\n   let wallColor, inLoop, exploreLoop;\n   var img = new Image();\n   img.src = \"../images/stone_none.png\";\n   let whitepanel = new Image();\n   whitepanel.src = \"../images/white.png\";\n   let goalpanel = new Image();\n   goalpanel.src = \"../images/Goal.png\";\n   let startpanel = new Image();\n   startpanel.src = \"../images/Start.png\";\n   let stone = new Image();\n   stone.src = \"../images/maze_stone.png\";\n   let pos_stone = [1, 1];\n   let last_pos = [1, 1];\n\n   let stoneflag = 0;\n   let stack_path = [];\n\n   // createCanvas(600, 600);\n   // colorMode(HSB);\n   class Vertex {\n     constructor(i, j) {\n       this.state = true;\n       this.x = margin + optMarginX + i * aside;\n       this.y = margin + optMarginY + j * aside;\n       this.goal = false;\n       this.start = false;\n       this.stone = false;\n       this.passed = false;\n     }\n\n     drawPanel() {\n       if (this.state) {\n         g.drawImage(img, this.x, this.y, aside, aside);\n       } else {\n         if (this.goal) {\n           g.drawImage(goalpanel, this.x, this.y, aside, aside);\n         } else if (this.start) {\n           g.drawImage(startpanel, this.x, this.y, aside, aside);\n         } else if (this.stone) {\n           g.drawImage(stone, this.x, this.y, aside, aside);\n         } else {\n           g.drawImage(whitepanel, this.x, this.y, aside, aside);\n         }\n       }\n     }\n   }\n\n   class Points {\n     constructor(i, j) {\n       this.x = i;\n       this.y = j;\n     }\n   }\n   init();\n   function getSize() {\n     // キャンバスのサイズを再設定\n     canvas.width = wrapper.offsetWidth;\n     canvas.height = wrapper.offsetHeight;\n   }\n\n   window.addEventListener(\"resize\", function () {\n     getSize();\n   });\n\n   window.addEventListener(\"load\", function () {\n     // キャンバスをウインドウサイズにする\n     getSize();\n\n     // sleep(2000);\n     init();\n   });\n   let onceflag = true;\n   function draw(ts) {\n     // console.log(\"draw\")\n     for (let j = 0; j < yCount; j++) {\n       for (let i = 0; i < xCount; i++) {\n         cells[i][j].drawPanel();\n       }\n     }\n     if (inLoop) {\n       digMaze();\n     } else if (exploreLoop) {\n       if (onceflag) {\n         // console.log(stack_path);\n         sleep(1000);\n         onceflag = false;\n       }\n       explore();\n     }\n     window.requestAnimationFrame((ts) => draw(ts));\n   }\n   window.requestAnimationFrame((ts) => draw(ts));\n  function sleep(waitTime) {\n           let startTime = new Date();\n           while (new Date() - startTime < waitTime);\n         }\n   function digMaze() {\n     console.log(\"dig\");\n     if (dirs.length == 0) {\n       //行き詰ったとき\n       let pickNextIndex = Math.floor(Math.random() * checkedCells.length);\n       // console.log(pickNextIndex)  //開通済みの道からランダムで選ぶ\n       let othercheckedCell = checkedCells[pickNextIndex];\n       checkedCells.splice(pickNextIndex, 1); //開通済みリストから取り除く\n       if (checkedCells.length == 0) {\n         //すべて探索したら左上と右下を開通する\n         cells[0][1].state = false;\n         cells[0][1].start = true;\n         cells[0][1].passed = true;\n         cells[xCount - 1][yCount - 2].state = false;\n         cells[xCount - 1][yCount - 2].goal = true;\n         cells[1][1].stone = true;\n         cells[1][1].passed = true;\n         inLoop = false;\n         console.log(\"End\");\n       }\n       cellX = othercheckedCell.x;\n       cellY = othercheckedCell.y;\n       dirs = [0, 1, 2, 3];\n     }\n     let tmpDirIndex = Math.floor(Math.random() * dirs.length); //進む方向を抽出\n     nextDir = dirs[tmpDirIndex];\n     dirs.splice(tmpDirIndex, 1);\n     switch (nextDir) {\n       case 0:\n         tmpX = 0;\n         tmpY = -2;\n         break;\n       case 1:\n         tmpX = 2;\n         tmpY = 0;\n         break;\n       case 2:\n         tmpX = 0;\n         tmpY = 2;\n         break;\n       case 3:\n         tmpX = -2;\n         tmpY = 0;\n         break;\n       default:\n         break;\n     }\n     let nextX = cellX + tmpX,\n       nextY = cellY + tmpY;\n     let betNextX = cellX + tmpX / 2,\n       betNextY = cellY + tmpY / 2;\n     if (nextX >= 0 && nextX < xCount && nextY >= 0 && nextY < yCount) {\n       //nextが範囲内のとき\n       if (cells[nextX][nextY].state == true) {\n         //nextが壁の時\n         cells[nextX][nextY].state = false; //nextを道にする\n         cells[betNextX][betNextY].state = false; //間も道にする\n         let flag = true;\n         for (let i = 0; i < checkedCells.length; i++) {\n           if (checkedCells[i].x == cellX && checkedCells[i].y == cellY) {\n             flag = false;\n           }\n         }\n         if (flag) checkedCells.push(new Points(cellX, cellY)); //開通済みのセルに登録\n         flag = 1;\n         cellX = nextX;\n         cellY = nextY;\n         dirs = [0, 1, 2, 3]; //進む方向リセット\n       }\n     }\n     // console.log(checkedCells)\n   }\n\n   function push_children(x, y) {\n     if (0 < x < xCount && 0 < y < yCount) {\n       if (!cells[x][y - 1].passed && !cells[x][y - 1].state) {\n         stack_path.push([x, y - 1]);\n         // console.log(stack_path[stack_path.length-1]);\n       }\n       if (!cells[x - 1][y].passed && !cells[x - 1][y].state) {\n         stack_path.push([x - 1, y]);\n         // console.log(stack_path[stack_path.length-1]);\n       }\n       if (!cells[x][y + 1].passed && !cells[x][y + 1].state) {\n         stack_path.push([x, y + 1]);\n         // console.log(stack_path[stack_path.length-1]);\n       }\n       if (!cells[x + 1][y].passed && !cells[x + 1][y].state) {\n         stack_path.push([x + 1, y]);\n         // console.log(stack_path[stack_path.length-1]);\n       }\n     }\n   }\n\n   function explore() {\n     console.log(\"explore\");\n     push_children(pos_stone[0], pos_stone[1]);\n     // console.log(!cells[stack_path[stack_path.length-1][0]][stack_path[stack_path.length-1][1]].state);\n     if (\n       !cells[stack_path[stack_path.length - 1][0]][\n         stack_path[stack_path.length - 1][1]\n       ].state\n     ) {\n       cells[stack_path[stack_path.length - 1][0]][\n         stack_path[stack_path.length - 1][1]\n       ].stone = true;\n       cells[stack_path[stack_path.length - 1][0]][\n         stack_path[stack_path.length - 1][1]\n       ].passed = true;\n       cells[last_pos[0]][last_pos[1]].stone = false;\n       if (\n         stack_path[stack_path.length - 1][0] == xCount - 2 &&\n         stack_path[stack_path.length - 1][1] == yCount - 2\n       ) {\n         exploreLoop = false;\n       }\n       pos_stone[0] = stack_path[stack_path.length - 1][0];\n       pos_stone[1] = stack_path[stack_path.length - 1][1];\n       last_pos[0] = stack_path[stack_path.length - 1][0];\n       last_pos[1] = stack_path[stack_path.length - 1][1];\n       stack_path.pop();\n     } else {\n       stack_path.pop();\n     }\n   }\n\n   function init() {\n     console.log(\"init load\");\n     // aside = Math.floor(Math.random(5, 40));\n     aside = 20; //1マスのサイズ\n     (optMarginX = 0), (optMarginY = 0);\n     dirs = [0, 1, 2, 3];\n     inLoop = true;\n     exploreLoop = true;\n     xCount = Math.floor((canvas.width - margin * 2) / aside); //横数\n     // xCount = 9;\n     if (xCount % 2 == 0) {\n       xCount--;\n       optMarginX = aside / 2;\n     }\n     yCount = Math.floor((canvas.height - margin * 2) / aside); //縦数\n     if (yCount % 2 == 0) {\n       yCount--;\n       optMarginY = aside / 2;\n     }\n     cells = Array.from(new Array(xCount), () => new Array(yCount).fill(null)); //縦＊横のnull行列\n     for (let j = 0; j < yCount; j++) {\n       for (let i = 0; i < xCount; i++) {\n         cells[i][j] = new Vertex(i, j);\n       }\n     }\n     cellX = Math.floor(Math.random() * (xCount - 2) + 1);\n     if (cellX % 2 == 0) {\n       cellX++;\n     }\n     cellY = Math.floor(Math.random() * (yCount - 2) + 1);\n     if (cellY % 2 == 0) {\n       cellY++;\n     }\n     cells[cellX][cellY].state = false;\n     checkedCells.push(new Points(cellX, cellY));\n   }\n</script>\n"],"mappings":";;EAEIA,KAAK,EAAC,mBAAmB;EACzBC,EAAE,EAAC,cAAc;EACjBC,KAAmE,EAAnE;IAAA;IAAA;IAAA;IAAA;EAAA;;gCAEAC,mBAAA,CAAkD;EAA1CC,KAAK,EAAC,EAAE;EAACC,MAAM,EAAC,EAAE;EAACJ,EAAE,EAAC;;oBAA9BK,UAAkD,C;;uBALpDC,mBAAA,CAMM,OANNC,UAMM,MAAAC,UAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}