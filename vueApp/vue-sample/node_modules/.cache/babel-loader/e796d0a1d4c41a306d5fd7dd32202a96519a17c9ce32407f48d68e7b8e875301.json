{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"HelloWorld\",\n  props: {\n    msg: String\n  },\n  mounted: function () {\n    this.ctx = this.$el.getContext('2d');\n  },\n  setup(props, ctx) {\n    var wrapper = null; // キャンバスの親要素\n    var canvas = null; // キャンバス\n    var g = null; // コンテキスト\n    var $id = function (id) {\n      return document.getElementById(id);\n    }; // DOM取得用\n    // キャンバスの親要素情報取得（親要素が無いとキャンバスのサイズが画面いっぱいに表示できないため）\n    wrapper = $id(\"id_container\");\n    // キャンバス情報取得\n    canvas = $id(\"MyCanvas\");\n    g = canvas.getContext(\"2d\");\n    const margin = 10;\n    let optMarginX, optMarginY;\n    let aside;\n    let xCount, yCount;\n    let cells = [];\n    let checkedCells = [];\n    let cellX, cellY, tmpX, tmpY;\n    let dirs = [];\n    let nextDir;\n    let wallColor, inLoop, exploreLoop;\n    var img = new Image();\n    img.src = \"../images/stone_none.png\";\n    let whitepanel = new Image();\n    whitepanel.src = \"../images/white.png\";\n    let goalpanel = new Image();\n    goalpanel.src = \"../images/Goal.png\";\n    let startpanel = new Image();\n    startpanel.src = \"../images/Start.png\";\n    let stone = new Image();\n    stone.src = \"../images/maze_stone.png\";\n    let pos_stone = [1, 1];\n    let last_pos = [1, 1];\n    let stoneflag = 0;\n    let stack_path = [];\n\n    // createCanvas(600, 600);\n    // colorMode(HSB);\n    class Vertex {\n      constructor(i, j) {\n        this.state = true;\n        this.x = margin + optMarginX + i * aside;\n        this.y = margin + optMarginY + j * aside;\n        this.goal = false;\n        this.start = false;\n        this.stone = false;\n        this.passed = false;\n      }\n      drawPanel() {\n        if (this.state) {\n          g.drawImage(img, this.x, this.y, aside, aside);\n        } else {\n          if (this.goal) {\n            g.drawImage(goalpanel, this.x, this.y, aside, aside);\n          } else if (this.start) {\n            g.drawImage(startpanel, this.x, this.y, aside, aside);\n          } else if (this.stone) {\n            g.drawImage(stone, this.x, this.y, aside, aside);\n          } else {\n            g.drawImage(whitepanel, this.x, this.y, aside, aside);\n          }\n        }\n      }\n    }\n    class Points {\n      constructor(i, j) {\n        this.x = i;\n        this.y = j;\n      }\n    }\n    init();\n    function getSize() {\n      // キャンバスのサイズを再設定\n      canvas.width = wrapper.offsetWidth;\n      canvas.height = wrapper.offsetHeight;\n    }\n    window.addEventListener(\"resize\", function () {\n      getSize();\n    });\n    window.addEventListener(\"load\", function () {\n      // キャンバスをウインドウサイズにする\n      getSize();\n\n      // sleep(2000);\n      init();\n    });\n    let onceflag = true;\n    function draw(ts) {\n      // console.log(\"draw\")\n      for (let j = 0; j < yCount; j++) {\n        for (let i = 0; i < xCount; i++) {\n          cells[i][j].drawPanel();\n        }\n      }\n      if (inLoop) {\n        digMaze();\n      } else if (exploreLoop) {\n        if (onceflag) {\n          // console.log(stack_path);\n          sleep(1000);\n          onceflag = false;\n        }\n        explore();\n      }\n      window.requestAnimationFrame(ts => draw(ts));\n    }\n    window.requestAnimationFrame(ts => draw(ts));\n    function sleep(waitTime) {\n      let startTime = new Date();\n      while (new Date() - startTime < waitTime);\n    }\n    function digMaze() {\n      console.log(\"dig\");\n      if (dirs.length == 0) {\n        //行き詰ったとき\n        let pickNextIndex = Math.floor(Math.random() * checkedCells.length);\n        // console.log(pickNextIndex)  //開通済みの道からランダムで選ぶ\n        let othercheckedCell = checkedCells[pickNextIndex];\n        checkedCells.splice(pickNextIndex, 1); //開通済みリストから取り除く\n        if (checkedCells.length == 0) {\n          //すべて探索したら左上と右下を開通する\n          cells[0][1].state = false;\n          cells[0][1].start = true;\n          cells[0][1].passed = true;\n          cells[xCount - 1][yCount - 2].state = false;\n          cells[xCount - 1][yCount - 2].goal = true;\n          cells[1][1].stone = true;\n          cells[1][1].passed = true;\n          inLoop = false;\n          console.log(\"End\");\n        }\n        cellX = othercheckedCell.x;\n        cellY = othercheckedCell.y;\n        dirs = [0, 1, 2, 3];\n      }\n      let tmpDirIndex = Math.floor(Math.random() * dirs.length); //進む方向を抽出\n      nextDir = dirs[tmpDirIndex];\n      dirs.splice(tmpDirIndex, 1);\n      switch (nextDir) {\n        case 0:\n          tmpX = 0;\n          tmpY = -2;\n          break;\n        case 1:\n          tmpX = 2;\n          tmpY = 0;\n          break;\n        case 2:\n          tmpX = 0;\n          tmpY = 2;\n          break;\n        case 3:\n          tmpX = -2;\n          tmpY = 0;\n          break;\n        default:\n          break;\n      }\n      let nextX = cellX + tmpX,\n        nextY = cellY + tmpY;\n      let betNextX = cellX + tmpX / 2,\n        betNextY = cellY + tmpY / 2;\n      if (nextX >= 0 && nextX < xCount && nextY >= 0 && nextY < yCount) {\n        //nextが範囲内のとき\n        if (cells[nextX][nextY].state == true) {\n          //nextが壁の時\n          cells[nextX][nextY].state = false; //nextを道にする\n          cells[betNextX][betNextY].state = false; //間も道にする\n          let flag = true;\n          for (let i = 0; i < checkedCells.length; i++) {\n            if (checkedCells[i].x == cellX && checkedCells[i].y == cellY) {\n              flag = false;\n            }\n          }\n          if (flag) checkedCells.push(new Points(cellX, cellY)); //開通済みのセルに登録\n          flag = 1;\n          cellX = nextX;\n          cellY = nextY;\n          dirs = [0, 1, 2, 3]; //進む方向リセット\n        }\n      }\n      // console.log(checkedCells)\n    }\n    function push_children(x, y) {\n      if (0 < x < xCount && 0 < y < yCount) {\n        if (!cells[x][y - 1].passed && !cells[x][y - 1].state) {\n          stack_path.push([x, y - 1]);\n          // console.log(stack_path[stack_path.length-1]);\n        }\n        if (!cells[x - 1][y].passed && !cells[x - 1][y].state) {\n          stack_path.push([x - 1, y]);\n          // console.log(stack_path[stack_path.length-1]);\n        }\n        if (!cells[x][y + 1].passed && !cells[x][y + 1].state) {\n          stack_path.push([x, y + 1]);\n          // console.log(stack_path[stack_path.length-1]);\n        }\n        if (!cells[x + 1][y].passed && !cells[x + 1][y].state) {\n          stack_path.push([x + 1, y]);\n          // console.log(stack_path[stack_path.length-1]);\n        }\n      }\n    }\n    function explore() {\n      console.log(\"explore\");\n      push_children(pos_stone[0], pos_stone[1]);\n      // console.log(!cells[stack_path[stack_path.length-1][0]][stack_path[stack_path.length-1][1]].state);\n      if (!cells[stack_path[stack_path.length - 1][0]][stack_path[stack_path.length - 1][1]].state) {\n        cells[stack_path[stack_path.length - 1][0]][stack_path[stack_path.length - 1][1]].stone = true;\n        cells[stack_path[stack_path.length - 1][0]][stack_path[stack_path.length - 1][1]].passed = true;\n        cells[last_pos[0]][last_pos[1]].stone = false;\n        if (stack_path[stack_path.length - 1][0] == xCount - 2 && stack_path[stack_path.length - 1][1] == yCount - 2) {\n          exploreLoop = false;\n        }\n        pos_stone[0] = stack_path[stack_path.length - 1][0];\n        pos_stone[1] = stack_path[stack_path.length - 1][1];\n        last_pos[0] = stack_path[stack_path.length - 1][0];\n        last_pos[1] = stack_path[stack_path.length - 1][1];\n        stack_path.pop();\n      } else {\n        stack_path.pop();\n      }\n    }\n    function init() {\n      console.log(\"init load\");\n      // aside = Math.floor(Math.random(5, 40));\n      aside = 20; //1マスのサイズ\n      optMarginX = 0, optMarginY = 0;\n      dirs = [0, 1, 2, 3];\n      inLoop = true;\n      exploreLoop = true;\n      xCount = Math.floor((canvas.width - margin * 2) / aside); //横数\n      // xCount = 9;\n      if (xCount % 2 == 0) {\n        xCount--;\n        optMarginX = aside / 2;\n      }\n      yCount = Math.floor((canvas.height - margin * 2) / aside); //縦数\n      if (yCount % 2 == 0) {\n        yCount--;\n        optMarginY = aside / 2;\n      }\n      cells = Array.from(new Array(xCount), () => new Array(yCount).fill(null)); //縦＊横のnull行列\n      for (let j = 0; j < yCount; j++) {\n        for (let i = 0; i < xCount; i++) {\n          cells[i][j] = new Vertex(i, j);\n        }\n      }\n      cellX = Math.floor(Math.random() * (xCount - 2) + 1);\n      if (cellX % 2 == 0) {\n        cellX++;\n      }\n      cellY = Math.floor(Math.random() * (yCount - 2) + 1);\n      if (cellY % 2 == 0) {\n        cellY++;\n      }\n      cells[cellX][cellY].state = false;\n      checkedCells.push(new Points(cellX, cellY));\n    }\n  }\n});","map":{"version":3,"names":["defineComponent","name","props","msg","String","mounted","ctx","$el","getContext","setup","wrapper","canvas","g","$id","id","document","getElementById","margin","optMarginX","optMarginY","aside","xCount","yCount","cells","checkedCells","cellX","cellY","tmpX","tmpY","dirs","nextDir","wallColor","inLoop","exploreLoop","img","Image","src","whitepanel","goalpanel","startpanel","stone","pos_stone","last_pos","stoneflag","stack_path","Vertex","constructor","i","j","state","x","y","goal","start","passed","drawPanel","drawImage","Points","init","getSize","width","offsetWidth","height","offsetHeight","window","addEventListener","onceflag","draw","ts","digMaze","sleep","explore","requestAnimationFrame","waitTime","startTime","Date","console","log","length","pickNextIndex","Math","floor","random","othercheckedCell","splice","tmpDirIndex","nextX","nextY","betNextX","betNextY","flag","push","push_children","pop","Array","from","fill"],"sources":["/app/vue-sample/src/components/MazeGenerator.vue"],"sourcesContent":["<template>\n  <canvas width=\"\" height=\"\" ref=\"MyCanvas\"></canvas>\n</template>\n<script lang=\"js\">\n   import { defineComponent } from \"vue\";\n\n   export default defineComponent({\n     name: \"HelloWorld\",\n     props: {\n       msg: String,\n     },\n     mounted: function(){\n        this.ctx = this.$el.getContext('2d');\n     },\n     setup(props, ctx) {\n  var wrapper = null; // キャンバスの親要素\n      var canvas = null; // キャンバス\n      var g = null; // コンテキスト\n      var $id = function (id) {\n        return document.getElementById(id);\n      }; // DOM取得用\n      // キャンバスの親要素情報取得（親要素が無いとキャンバスのサイズが画面いっぱいに表示できないため）\n      wrapper = $id(\"id_container\");\n      // キャンバス情報取得\n      canvas = $id(\"MyCanvas\");\n      g = canvas.getContext(\"2d\");\n      const margin = 10;\n      let optMarginX, optMarginY;\n      let aside;\n      let xCount, yCount;\n      let cells = [];\n      let checkedCells = [];\n      let cellX, cellY, tmpX, tmpY;\n      let dirs = [];\n      let nextDir;\n      let wallColor, inLoop, exploreLoop;\n      var img = new Image();\n      img.src = \"../images/stone_none.png\";\n      let whitepanel = new Image();\n      whitepanel.src = \"../images/white.png\";\n      let goalpanel = new Image();\n      goalpanel.src = \"../images/Goal.png\";\n      let startpanel = new Image();\n      startpanel.src = \"../images/Start.png\";\n      let stone = new Image();\n      stone.src = \"../images/maze_stone.png\";\n      let pos_stone = [1, 1];\n      let last_pos = [1, 1];\n\n      let stoneflag = 0;\n      let stack_path = [];\n\n      // createCanvas(600, 600);\n      // colorMode(HSB);\n      class Vertex {\n        constructor(i, j) {\n          this.state = true;\n          this.x = margin + optMarginX + i * aside;\n          this.y = margin + optMarginY + j * aside;\n          this.goal = false;\n          this.start = false;\n          this.stone = false;\n          this.passed = false;\n        }\n\n        drawPanel() {\n          if (this.state) {\n            g.drawImage(img, this.x, this.y, aside, aside);\n          } else {\n            if (this.goal) {\n              g.drawImage(goalpanel, this.x, this.y, aside, aside);\n            } else if (this.start) {\n              g.drawImage(startpanel, this.x, this.y, aside, aside);\n            } else if (this.stone) {\n              g.drawImage(stone, this.x, this.y, aside, aside);\n            } else {\n              g.drawImage(whitepanel, this.x, this.y, aside, aside);\n            }\n          }\n        }\n      }\n\n      class Points {\n        constructor(i, j) {\n          this.x = i;\n          this.y = j;\n        }\n      }\n      init();\n      function getSize() {\n        // キャンバスのサイズを再設定\n        canvas.width = wrapper.offsetWidth;\n        canvas.height = wrapper.offsetHeight;\n      }\n\n      window.addEventListener(\"resize\", function () {\n        getSize();\n      });\n\n      window.addEventListener(\"load\", function () {\n        // キャンバスをウインドウサイズにする\n        getSize();\n\n        // sleep(2000);\n        init();\n      });\n      let onceflag = true;\n      function draw(ts) {\n        // console.log(\"draw\")\n        for (let j = 0; j < yCount; j++) {\n          for (let i = 0; i < xCount; i++) {\n            cells[i][j].drawPanel();\n          }\n        }\n        if (inLoop) {\n          digMaze();\n        } else if (exploreLoop) {\n          if (onceflag) {\n            // console.log(stack_path);\n            sleep(1000);\n            onceflag = false;\n          }\n          explore();\n        }\n        window.requestAnimationFrame((ts) => draw(ts));\n      }\n      window.requestAnimationFrame((ts) => draw(ts));\n     function sleep(waitTime) {\n              let startTime = new Date();\n              while (new Date() - startTime < waitTime);\n            }\n      function digMaze() {\n        console.log(\"dig\");\n        if (dirs.length == 0) {\n          //行き詰ったとき\n          let pickNextIndex = Math.floor(Math.random() * checkedCells.length);\n          // console.log(pickNextIndex)  //開通済みの道からランダムで選ぶ\n          let othercheckedCell = checkedCells[pickNextIndex];\n          checkedCells.splice(pickNextIndex, 1); //開通済みリストから取り除く\n          if (checkedCells.length == 0) {\n            //すべて探索したら左上と右下を開通する\n            cells[0][1].state = false;\n            cells[0][1].start = true;\n            cells[0][1].passed = true;\n            cells[xCount - 1][yCount - 2].state = false;\n            cells[xCount - 1][yCount - 2].goal = true;\n            cells[1][1].stone = true;\n            cells[1][1].passed = true;\n            inLoop = false;\n            console.log(\"End\");\n          }\n          cellX = othercheckedCell.x;\n          cellY = othercheckedCell.y;\n          dirs = [0, 1, 2, 3];\n        }\n        let tmpDirIndex = Math.floor(Math.random() * dirs.length); //進む方向を抽出\n        nextDir = dirs[tmpDirIndex];\n        dirs.splice(tmpDirIndex, 1);\n        switch (nextDir) {\n          case 0:\n            tmpX = 0;\n            tmpY = -2;\n            break;\n          case 1:\n            tmpX = 2;\n            tmpY = 0;\n            break;\n          case 2:\n            tmpX = 0;\n            tmpY = 2;\n            break;\n          case 3:\n            tmpX = -2;\n            tmpY = 0;\n            break;\n          default:\n            break;\n        }\n        let nextX = cellX + tmpX,\n          nextY = cellY + tmpY;\n        let betNextX = cellX + tmpX / 2,\n          betNextY = cellY + tmpY / 2;\n        if (nextX >= 0 && nextX < xCount && nextY >= 0 && nextY < yCount) {\n          //nextが範囲内のとき\n          if (cells[nextX][nextY].state == true) {\n            //nextが壁の時\n            cells[nextX][nextY].state = false; //nextを道にする\n            cells[betNextX][betNextY].state = false; //間も道にする\n            let flag = true;\n            for (let i = 0; i < checkedCells.length; i++) {\n              if (checkedCells[i].x == cellX && checkedCells[i].y == cellY) {\n                flag = false;\n              }\n            }\n            if (flag) checkedCells.push(new Points(cellX, cellY)); //開通済みのセルに登録\n            flag = 1;\n            cellX = nextX;\n            cellY = nextY;\n            dirs = [0, 1, 2, 3]; //進む方向リセット\n          }\n        }\n        // console.log(checkedCells)\n      }\n\n      function push_children(x, y) {\n        if (0 < x < xCount && 0 < y < yCount) {\n          if (!cells[x][y - 1].passed && !cells[x][y - 1].state) {\n            stack_path.push([x, y - 1]);\n            // console.log(stack_path[stack_path.length-1]);\n          }\n          if (!cells[x - 1][y].passed && !cells[x - 1][y].state) {\n            stack_path.push([x - 1, y]);\n            // console.log(stack_path[stack_path.length-1]);\n          }\n          if (!cells[x][y + 1].passed && !cells[x][y + 1].state) {\n            stack_path.push([x, y + 1]);\n            // console.log(stack_path[stack_path.length-1]);\n          }\n          if (!cells[x + 1][y].passed && !cells[x + 1][y].state) {\n            stack_path.push([x + 1, y]);\n            // console.log(stack_path[stack_path.length-1]);\n          }\n        }\n      }\n\n      function explore() {\n        console.log(\"explore\");\n        push_children(pos_stone[0], pos_stone[1]);\n        // console.log(!cells[stack_path[stack_path.length-1][0]][stack_path[stack_path.length-1][1]].state);\n        if (\n          !cells[stack_path[stack_path.length - 1][0]][\n            stack_path[stack_path.length - 1][1]\n          ].state\n        ) {\n          cells[stack_path[stack_path.length - 1][0]][\n            stack_path[stack_path.length - 1][1]\n          ].stone = true;\n          cells[stack_path[stack_path.length - 1][0]][\n            stack_path[stack_path.length - 1][1]\n          ].passed = true;\n          cells[last_pos[0]][last_pos[1]].stone = false;\n          if (\n            stack_path[stack_path.length - 1][0] == xCount - 2 &&\n            stack_path[stack_path.length - 1][1] == yCount - 2\n          ) {\n            exploreLoop = false;\n          }\n          pos_stone[0] = stack_path[stack_path.length - 1][0];\n          pos_stone[1] = stack_path[stack_path.length - 1][1];\n          last_pos[0] = stack_path[stack_path.length - 1][0];\n          last_pos[1] = stack_path[stack_path.length - 1][1];\n          stack_path.pop();\n        } else {\n          stack_path.pop();\n        }\n      }\n\n      function init() {\n        console.log(\"init load\");\n        // aside = Math.floor(Math.random(5, 40));\n        aside = 20; //1マスのサイズ\n        (optMarginX = 0), (optMarginY = 0);\n        dirs = [0, 1, 2, 3];\n        inLoop = true;\n        exploreLoop = true;\n        xCount = Math.floor((canvas.width - margin * 2) / aside); //横数\n        // xCount = 9;\n        if (xCount % 2 == 0) {\n          xCount--;\n          optMarginX = aside / 2;\n        }\n        yCount = Math.floor((canvas.height - margin * 2) / aside); //縦数\n        if (yCount % 2 == 0) {\n          yCount--;\n          optMarginY = aside / 2;\n        }\n        cells = Array.from(new Array(xCount), () => new Array(yCount).fill(null)); //縦＊横のnull行列\n        for (let j = 0; j < yCount; j++) {\n          for (let i = 0; i < xCount; i++) {\n            cells[i][j] = new Vertex(i, j);\n          }\n        }\n        cellX = Math.floor(Math.random() * (xCount - 2) + 1);\n        if (cellX % 2 == 0) {\n          cellX++;\n        }\n        cellY = Math.floor(Math.random() * (yCount - 2) + 1);\n        if (cellY % 2 == 0) {\n          cellY++;\n        }\n        cells[cellX][cellY].state = false;\n        checkedCells.push(new Points(cellX, cellY));\n      }\n     }\n   });\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}